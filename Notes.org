#+TITLE:  Clojure from a Haskell perspective
#+AUTHOR: Ivan Lazar Miljenovic
#+EMAIL:  Ivan.Miljenovic@gmail.com
#+LANGUAGE: en
#+STARTUP: showall

* Why are you looking at Clojure?

Yes, [[http://clojure.org/][Clojure]] is a dynamically-typed JVM language with no
language-level management of side-effects, three reasons that - as a
Haskeller - reduces its appeal...

... until I /needed/ a JVM language to try out different No-SQL DBs
(most of the ones I was looking at were on the JVM), and found that
[[http://www.scala-lang.org/][Scala]] was too "what the?" for my tastes (including opinions of other
people that I'm working with), [[https://github.com/Frege/frege][Frege]] seems a bit too immature (even
though we use Haskell for our main product) and none of the other
languages really appealed to me (I /definitely/ didn't want to use
Java!).

Besides, Clojure has some good points going for it: it seems to
encourage a functional style with managed side-effects (just not
enforced like in Haskell) and it uses STM for concurrency.

Furthermore, I don't mind parentheses (note that I'm writing this in
[[http://orgmode.org/][org-mode]] in Emacs) and one of the DBs I'm investigating is [[http://www.datomic.com/][Datomic]],
which is written in Clojure.

** How I'm learning

I tried to find some kind of "I know how to program, I just want to
know how to program in /Clojure/" tutorial (ideally aimed at
Haskellers, similar in vein to [[https://wiki.haskell.org/Haskell_Tutorial_for_C_Programmers][Haskell Tutorial for C Programmers]] but
sufficing for something akin to [[http://book.realworldhaskell.org/][Real World Haskell]]) which doesn't
assume that it needs to teach me what a number is, what a ~String~ is,
etc.

But I couldn't find anything in that vein: most online tutorials seem
to assume you've never programmed before.  There did seem to be a
start at "Learn Clojure the Hard Way" by a few people, but without any
updates for a few years and only a few chapters written.  The closest
thing I can find to being thrown into the deep-end of Clojure was a
blog post entitled [[http://mishadoff.com/blog/clojure-design-patterns/][Clojure Design Patterns]]; I was able to get an idea
of the syntax, etc. by reading this.  The rest of the blanks I filled
in using [[http://www.braveclojure.com/][Clojure for the Brave and True]].

So I hope that this document becomes in part an aid in people trying
to pick Clojure up quickly.


* Quick Summary

** Things to like

Variable-argument functions are nice, even if they /are/ implemented
by basically pattern matching on the number of arguments provided.

Having in-built documentation support in the REPL using ~(doc
function-name)~; the closest Haskell has is [[http://hackage.haskell.org/package/haskell-docs][haskell-docs]].  There is
also ~(source function-name)~ for non-inbuilt functions.

** Things to dislike

(I'm ignoring anything to do with the JVM here, like the utter joy in
dealing with security certificates in corporate environments.)

One of the motivations behind [[https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs][SICP]] is (from the Preface to the 1st Edition):

#+BEGIN_QUOTE
This is one great advantage of Lisp-like languages: They have very few
ways of forming compound expressions, and almost no syntactic
structure. [...] After a short time we forget about syntactic details
of the language (because there are none) [...]
#+END_QUOTE

Yet whilst it is most definitely a Lisp-like language, the various
symbols and other syntactical constructs seems designed in part to
make the SICP authors cry.

In addition to this, there seems to be a lot more fiddling required in
terms of file-structure, layout, etc.: the (current? there seems to be
mention of others) build tool [[http://leiningen.org/][Leiningen]] is a lot more opinionated in
terms of project filestructure (in that you start a project by asking
it to create a template, and then putting files where it tells you
to); there is seemingly extra metadata files used for /reader
conditionals/, and even trying to have a system-wide install of a
helper tool for the REPL requires specifying the exact version in a
configuration file.

Finally: the REPL is /slow/ to start-up... that said, there seems to
be less of a need to restart it often like with =ghci= (e.g. ~.cabal~
file changed? Restart ghci!  Want to change to a different section of
your project? Restart ghci!)
